#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
#  Portions of this software are Copyright (c) 2011 Univa Corporation.
#
##########################################################################
#___INFO__MARK_END__

# Define the global veriables to give them back
global check_name check_description check_needs check_functions
global check_category
global ts_config
global check_root_access_needs
set check_root_access_needs "yes"

# set description for each level
set check_description(0)  "check every qsub option"

set check_name         "qsub"
set check_category     "COMPATIBILITY SYSTEM L10N EVENTCLIENT VERIFIED"
set check_needs        "init_core_system"       ;# dependencies of this check (name of other check)

# setup and cleanup functions
set check_setup_function "qsub_setup"
set check_cleanup_function "qsub_cleanup"

# define test's procedure order
set check_functions {}
lappend check_functions "check_submit"
lappend check_functions "qsub_starter_method"
lappend check_functions "check_start_time"
lappend check_functions "check_hold"
lappend check_functions "check_option_ac"
lappend check_functions "check_option_A"
lappend check_functions "check_option_clear"
lappend check_functions "check_option_c"
lappend check_functions "check_option_ckpt"
lappend check_functions "check_option_cwd"
lappend check_functions "check_option_C"
lappend check_functions "check_option_dc"
lappend check_functions "check_option_e"
lappend check_functions "check_option_hard"
lappend check_functions "check_option_help"
lappend check_functions "check_option_hold_jid"
lappend check_functions "check_option_j_y"
lappend check_functions "check_option_j_n"
lappend check_functions "check_option_l"
lappend check_functions "check_option_m"
lappend check_functions "check_option_notify"
lappend check_functions "check_option_now_yes"
lappend check_functions "check_option_now_no"
lappend check_functions "check_option_M"
lappend check_functions "check_option_N"
lappend check_functions "check_option_o"
lappend check_functions "check_option_P"
lappend check_functions "check_option_p"
lappend check_functions "check_option_pe"
lappend check_functions "check_option_q"
lappend check_functions "check_option_r_y"
lappend check_functions "check_option_r_n"
lappend check_functions "check_option_sc"
lappend check_functions "check_option_soft"
lappend check_functions "check_option_S"
lappend check_functions "check_option_t"
lappend check_functions "check_option_v"
lappend check_functions "check_option_verify"
lappend check_functions "check_option_V"
lappend check_functions "check_option_@"
lappend check_functions "check_huge_script"
lappend check_functions "check_qhold_jobname"
lappend check_functions "check_qsub_ts_iz_72" ;# Testcase for TS IZ 72

lappend check_functions "check_deadline"
lappend check_functions "check_option_sync"
lappend check_functions "check_option_sync_t"
lappend check_functions "check_option_terse"

lappend check_functions "qsub_wd"         ;# test the -wd <dir>/-cwd options
lappend check_functions "check_qsub_ts_iz_145" ; # Testcase for TS IZ 145
lappend check_functions "check_sync_failover" ;# Testcase for TS IZ 3
lappend check_functions "check_option_pty"
lappend check_functions "check_option_pty_no"
lappend check_functions "check_option_pty_io"

proc qsub_setup {} {
   global ts_config
   global CHECK_JOB_OUTPUT_DIR
   global stored_configuration
   global job_output_dir test_host default_args default_q_args default_h_args
   global steps_per_queue size_interval
   global HUGE_SCRIPT_SIZE HUGE_SCRIPT_PATTERN HUGE_SCRIPT_TIMEOUT
   global HUGE_SCRIPT_STEPS HUGE_SCRIPT_MAX_SIZE

   # set some global variables
   set num_queues [llength $ts_config(unique_arch_nodes)] 
   set job_output_dir $CHECK_JOB_OUTPUT_DIR

   # run host specific tests on a random host
   set test_host [host_conf_get_suited_hosts]

   # set default jobargs
   set default_args "-o $job_output_dir -e $job_output_dir $ts_config(product_root)/examples/jobs/sleeper.sh 5"
   set qinstance [get_queue_instance "all.q" $test_host]
   set default_q_args "-q $qinstance $default_args"
   set default_h_args "-l h=${test_host} $default_args"

   # setup huge_script test
   set HUGE_SCRIPT_MIN_SIZE 0
   set HUGE_SCRIPT_MAX_SIZE [expr 16 * 1024 * 1024]
   set HUGE_SCRIPT_STEPS    100
   set HUGE_SCRIPT_TIMEOUT  1000
   set HUGE_SCRIPT_PATTERN  "generated huge script file for testsuite, 100 characters per line .............................. end"
   set steps_per_queue [expr $HUGE_SCRIPT_STEPS / $num_queues]
   if {[expr $steps_per_queue * $num_queues] < $HUGE_SCRIPT_STEPS} {
      incr steps_per_queue
   }
   set steps_total [expr $steps_per_queue * $num_queues]
   set size_interval [expr $HUGE_SCRIPT_MAX_SIZE / $steps_total]

   # backup global config
   get_config stored_configuration
  
   # set config for fast scheduling / fast writing of accounting record
   set my_config(reporting_params) "accounting=true reporting=false flush_time=00:00:01 joblog=true sharelog=00:10:00"
   set_config my_config
}

proc qsub_cleanup {} {
   global ts_config
   global stored_configuration
   global job_output_dir test_host default_args default_q_args default_h_args
   global steps_per_queue size_interval
   global HUGE_SCRIPT_SIZE HUGE_SCRIPT_PATTERN HUGE_SCRIPT_TIMEOUT
   global HUGE_SCRIPT_STEPS HUGE_SCRIPT_MAX_SIZE

   set spool_dir [get_spool_dir $ts_config(master_host)  "qmaster"] 
   if {[is_qmaster_alive $ts_config(master_host) $spool_dir] != 1} {
      if {[is_scheduler_alive $ts_config(master_host) $spool_dir] != 1} {
         startup_qmaster 1
      } else {
      startup_qmaster 0
      }
   }

   delete_all_jobs
   wait_for_end_of_all_jobs

   reset_config stored_configuration

   # unset our test global variables
   foreach var "stored_configuration job_output_dir test_host default_args default_q_args default_h_args steps_per_queue size_interval HUGE_SCRIPT_SIZE HUGE_SCRIPT_PATTERN HUGE_SCRIPT_TIMEOUT HUGE_SCRIPT_STEPS HUGE_SCRIPT_MAX_SIZE" {
      if {[info exists $var]} {
         unset $var
      }
   }
}

proc qsub_submit_check {jobargs expect_submit_error {user ""} {host ""} {output_files 2}} {
   global ts_config CHECK_FIRST_FOREIGN_SYSTEM_USER
   global job_output_dir

   # default user is the first "foreign" user!
   if {$user == ""} {
      set user $CHECK_FIRST_FOREIGN_SYSTEM_USER
   }

   # default submit host is "any host"
   if {$host == ""} {
      set host [host_conf_get_suited_hosts]
   }

   # if we expect a submit error, submit_job shall not do error checking
   set submit_error_check 1
   if {$expect_submit_error} {
      set submit_error_check 0
   }

   # submit job and evaluate result
   set job_id [submit_job $jobargs $submit_error_check 60 $host $user]
   if {$expect_submit_error} {
      if {$job_id > 0} {
         ts_log_severe "submission of job \"$jobargs\" as user $user on host \"$host\" should have failed"
         delete_job $job_id
      }
      # are done
      return 0
   } else {
      if {$job_id < 0} {
         ts_log_severe "submission of job \"$jobargs\" as user $user on host \"$host\" failed:\nerror $job_id"
         return 0
      }
   }

   # wait for job accounting record and expect 1 or 2 ($output_files) output/error files
   set time [expr [timestamp] + 300] 
   while {[timestamp] < $time}  {
      after 1000
      set back [was_job_running $job_id 0]
      if {$back != -1} {
         set back [del_job_files $job_id $job_output_dir $output_files]
         if {$back != $output_files} {
            ts_log_severe "job $job_id (\"$jobargs\") did not produce error and output file"
            return 0
         } else {
            # job ran through successfully
            return $job_id
         }
      }
   }

   # if we get here, we didn't find an accounting record within reasonable time
   ts_log_severe "timeout waiting for job $job_id (\"$jobargs\")"

   # cleanup
   delete_job $job_id
   del_job_files $job_id $job_output_dir 2
   return 0
}
 
#                                                             max. column:     |
#****** qsub/check_submit() ******
# 
#  NAME
#     check_submit -- ??? 
#
#  SYNOPSIS
#     check_submit { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_submit {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory
   
   # submit from every architecture
   foreach host $ts_config(unique_arch_nodes) {
      ts_log_fine "--> submit on host $host"
      qsub_submit_check $default_args 0 "" $host
   }

   # submit to every architecture
   foreach host $ts_config(unique_arch_nodes) {
      ts_log_fine "--> submit to host $host"
      qsub_submit_check "-l h=${host} $default_args" 0
   }
}

proc qsub_starter_method {} {
   global ts_config CHECK_ACTUAL_TEST_PATH
   global job_output_dir test_host
   global default_q_args default_h_args

   set ok 1

   # first clean up output directory:
   setup_output_directory
  
   # set starter method
   set change_array(starter_method) "$CHECK_ACTUAL_TEST_PATH/starter.sh"
   mod_queue all.q "" change_array

   set jobargs $default_q_args
   set result [submit_job $jobargs]

   if {$result < 0} {
      ts_log_severe "could not submit job: $jobargs"
      set ok 0
   }

   # Wait job to run and for end of job
   if {$ok} {
      set back [wait_for_jobstart $result "leeper" 300]
      if {$back != 0} {
         ts_log_severe "job $result doesn't start"
         set ok 0
      }
   }

   # Wait for end of job
   if {$ok} {
      set back [wait_for_jobend $result "leeper" 300 0]
      if {$back != 0} {
         ts_log_severe "job $result doesn't stop"
         set ok 0
      }
   }

   # check output file, should contain output from starter method
   if {$ok} {
      after 2000
      set outfilename "$job_output_dir/Sleeper.o$result"
      ts_log_fine "checking output file $outfilename"

      if {![file exists $outfilename]} {
         ts_log_severe "output file for job $result on host $test_host does not exist"
         set ok 0
      } else {
         set f [open $outfilename r]
         set files_ok 0
         set num_lines 0
         while {[gets $f line] >= 0} {
            incr num_lines
            ts_log_fine $line
               if {[string compare $line "starter method started"] == 0} {
               set files_ok 1
               break
            }
         }
         if {$num_lines == 0} {
            ts_log_severe "error reading from job output file for job $result on host $test_host"
            set ok 0
         } else {
            if {$files_ok == 0} {
               ts_log_severe "starter method was not started for job $result on host $test_host"
               set ok 0
            }
         }  
         close $f
      }
   }

   # cleanup
   set back [del_job_files $result $job_output_dir 2]
   if {$back != 2} {
      ts_log_severe "job $result did not produce error and output file\njobargs: $jobargs"
   }
   if {!$ok && $result > 0} {
      delete_job $result
   }

   # unset starter method
   set change_array(starter_method) "none"
   mod_queue all.q "" change_array
}

#                                                             max. column:     |
#****** qsub/setup_output_directory() ******
# 
#  NAME
#     setup_output_directory -- ??? 
#
#  SYNOPSIS
#     setup_output_directory { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_output_directory {} {
   global ts_config
   global job_output_dir 
   
   if {[string length $job_output_dir] < 5} {
      ts_log_severe "job output dir path must at least have 5 characters\ngot \"$job_output_dir\""
      return -1
   }

   # create directory, if it does not yet exist
   # if it already exists, delete all files in it
   set files_deleted 0
   if {![file isdirectory "$job_output_dir"]} {
      file mkdir "$job_output_dir"
      ts_log_fine "new output directory \"$job_output_dir\" generated!"
   } else {
      ts_log_fine "deleting all files in output directory \"$job_output_dir\"!"
      set files [glob -nocomplain $job_output_dir/*]
      foreach elem $files {
         ts_log_fine $elem
         if {[file isfile $elem] == 1 } {
            ts_log_fine "deleting file $elem"
            incr files_deleted
            delete_file $elem
         }
      }
   }

   # make sure every user may create output files here
   file attributes $job_output_dir -permissions "a+rwx"

   return $files_deleted
}

#                                                             max. column:     |
#****** qsub/check_hold() ******
# 
#  NAME
#     check_hold -- ??? 
#
#  SYNOPSIS
#     check_hold { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_hold {} {
   global ts_config
   global job_output_dir test_host default_args

   set ok 1

   # first clean up output directory:  
   setup_output_directory

   set jobargs "-h $default_args"
   set result [submit_job $jobargs] 
   if {$result < 0} {
      ts_log_severe "error submitting job \"$jobargs\"\nerror $result"
   }
 
   # wait for job to get in pending state 
   if {[wait_for_jobpending $result "leeper" 200] != 0} {
      ts_log_severe "job $result is not in pending state"
      set ok 0
   }

   # job should not run within the next 2 minutes 
   if {$ok} {
      ts_log_fine "check_hold - set hold for job $result, job should not start"
      if {[wait_for_jobstart $result "leeper" 120 0] != -1} {
         ts_log_severe "job $result should not run until yet"
         set ok 0
      }
   }

   # release job
   if {$ok} {
      ts_log_fine "check_hold - ok now we release the job"
      release_job $result
   }

   # wait for job to start
   if {$ok} {
      if {[wait_for_jobstart $result "leeper" 300] == -1} {
         ts_log_severe "check_hold - job $result doesn't start"
         set ok 0
      }
   }
 
   # wait for end of job
   if {$ok} {
      if {[wait_for_jobend $result "leeper" 300 0] == -1} {
         ts_log_severe "check_hold - job $result doesn't stop"
         set ok 0
      }
   }

   # cleanup
   set back [del_job_files $result $job_output_dir 2]
   if {$back != 2} {
      ts_log_severe "job $result did not produce error and output file\njobargs: $jobargs"
   }
   if {!$ok && $result > 0} {
      delete_job $result
   }
}

#                                                             max. column:     |
#****** qsub/check_start_time() ******
# 
#  NAME
#     check_start_time -- ??? 
#
#  SYNOPSIS
#     check_start_time { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_start_time {} {
   global ts_config
   global job_output_dir test_host

   # first clean up output directory:  
   setup_output_directory

   set now [clock seconds]
   set then [expr $now + 120]

   set start [clock format $then -format "%Y%m%d%H%M.%S"]

   set jobargs "-a $start -l h=${test_host} -o $job_output_dir -e $job_output_dir $ts_config(product_root)/examples/jobs/sleeper.sh 10"

   set ok 1

   # submit job
   set result [submit_job $jobargs]
   if {$result < 0} {
      ts_log_severe "error submitting job \"$jobargs\"\nerror $result"
   }

   # wait for job to get in pending state
   if {[wait_for_jobpending $result "leeper" 200] != 0} {
      ts_log_severe "job $result is not in pending state"
      set ok 0
   }

   # calulate time until job should run
   if {$ok} {
      set wait_time 10
      ts_log_fine "check_start_time - job should not start the next $wait_time seconds"
      set now [clock seconds]
      if {[wait_for_jobstart $result "leeper" $wait_time 0] != -1} {
         ts_log_severe "check_start_time - job $result should not run until yet"
         set ok 0
      }
   }

   # wait for job to start
   if {$ok} {
      ts_log_fine "check_start_time - ok now the job should start"
      if {[wait_for_jobstart $result "leeper" 300] == -1} {
         ts_log_severe "check_start_time - job $result doesn't start"
         set ok 0
      }
   }
 
   # wait for end of job
   if {$ok} {
      if {[wait_for_jobend $result "leeper" 300 0] == -1} {
         ts_log_severe "check_start_time - job $result doesn't stop"
         set ok 0
      }
   }

   # cleanup
   set back [del_job_files $result $job_output_dir 2]
   if {$back != 2} {
      ts_log_severe "job $result did not produce error and output file\njobargs: $jobargs"
   }
   if {!$ok && $result > 0} {
      delete_job $result
   }
}

#                                                             max. column:     |
#****** qsub/check_option_ac() ******
# 
#  NAME
#     check_option_ac -- ??? 
#
#  SYNOPSIS
#     check_option_ac { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_ac {} {
   global ts_config CHECK_ACTUAL_TEST_PATH
   global job_output_dir test_host

   # first clean up output directory:
   setup_output_directory

   set option "-ac myvar1=\"test 1\" -ac myvar2='test 2'"
   # We use a special job script which contains context variable settings
   set jobargs "$option -l h=${test_host} -o $job_output_dir -e $job_output_dir $CHECK_ACTUAL_TEST_PATH/sleeper.sh 60"
   set result [submit_job $jobargs 0]

   if {$result < 0} {
      ts_log_severe "error submitting job \"$jobargs\"\nerror $result"
      return
   }

   set qstatoutput [start_sge_bin "qstat" "-j $result"]

   if {$prg_exit_state != 0} {
      ts_log_severe "error executing qstat -j $result"
      return
   }

   if {[regexp {context:([^\r\n]+\r?\n)} $qstatoutput match vars] != 1} {
      ts_log_severe "qsub $option - qsub error: context variables were not set"
      return
   }

   ts_log_fine "context variables: $vars"

   if {[regexp {[ \t,]myvar1=test 1[,\r\n]} $vars match] != 1} {
      ts_log_severe "qsub $option - qsub error: command-line context variable was not set"
      return
   } elseif {[regexp {[ \t,]myvar2=test 2[,\r\n]} $vars match] != 1} {
      ts_log_severe "qsub $option - qsub error: command-line context variable was not set"
      return
   } elseif {[regexp {[ \t,]myvar3=test 3[,\r\n]} $vars match] != 1} {
      ts_log_severe "qsub $option - qsub error: inline context variable was not set"
      return
   } elseif {[regexp {[ \t,]myvar4=test 4[,\r\n]} $vars match] != 1} {
      if {[regexp {[ \t,]myvar4='test 4'[,\r\n]} $vars match] == 1} {
         ts_log_info "qsub $option - qsub error: issue IZ1850 encountered only fixed for versions > 6.0"
         return
      }

      ts_log_severe "qsub $option - qsub error: inline context variable was not set"
      return
   }

   set time [expr [timestamp] + 300]
   while {[timestamp] < $time}  {
      after 1000
      set back [was_job_running $result 0]
      if {$back != -1} {
         set back [del_job_files $result $job_output_dir 2]
         if {$back != 2} {
            ts_log_severe "job $result did not produce error and output file\njobargs: $jobargs"
         }
         return
      }
   }
 
   ts_log_severe "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_A() ******
# 
#  NAME
#     check_option_A -- ??? 
#
#  SYNOPSIS
#     check_option_A { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_A {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   # positive tests
   foreach string [valid_job_has_valid_account_string "-A"] {
      set option "-A '$string'"
      set jobargs "$option $default_args"
      set job_id [qsub_submit_check $jobargs 0]

      if {$job_id > 0} {
         get_qacct $job_id
         set acct_string $qacct_info(account)
         if {$acct_string != $string} {
            ts_log_severe "account string requested with -A option missing in accounting record:\nexpected $string, but accounting record contains $acct_string\nfor job $job_id"
         }
      }
   }

   # negative tests
   foreach string [invalid_job_has_valid_account_string "-A"] {
      set option "-A '$string'"
      set jobargs "$option $default_args"
      set job_id [qsub_submit_check $jobargs 1]
   }
}

#                                                             max. column:     |
#****** qsub/check_option_clear() ******
# 
#  NAME
#     check_option_clear -- ??? 
#
#  SYNOPSIS
#     check_option_clear { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_clear {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-A blahblah -clear"
   set jobargs "$option $default_args"
   set job_id [qsub_submit_check $jobargs 0]

   if {$job_id > 0} {
      get_qacct $job_id
      if {$qacct_info(account) == "blahblah"} {
         ts_log_severe "-clear option didn't earlier -A option"
      }
   }
}

#                                                             max. column:     |
#****** qsub/check_option_c() ******
# 
#  NAME
#     check_option_c -- ??? 
#
#  SYNOPSIS
#     check_option_c { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_c {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-c n"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_ckpt() ******
# 
#  NAME
#     check_option_ckpt -- ??? 
#
#  SYNOPSIS
#     check_option_ckpt { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_ckpt {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-ckpt testcheckpointobject"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_cwd() ******
# 
#  NAME
#     check_option_cwd -- ??? 
#
#  SYNOPSIS
#     check_option_cwd { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_cwd {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-cwd"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_C() ******
# 
#  NAME
#     check_option_C -- ??? 
#
#  SYNOPSIS
#     check_option_C { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_C {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-C TESTPREFIX"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_dc() ******
# 
#  NAME
#     check_option_dc -- ??? 
#
#  SYNOPSIS
#     check_option_dc { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_dc {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-dc myvar,myvar2"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_e() ******
# 
#  NAME
#     check_option_e -- ??? 
#
#  SYNOPSIS
#     check_option_e { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_e {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   # we submit just with default args - they contain the -e option
   qsub_submit_check $default_args 0
}

#                                                             max. column:     |
#****** qsub/check_option_hard() ******
# 
#  NAME
#     check_option_hard -- ??? 
#
#  SYNOPSIS
#     check_option_hard { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_hard {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-hard"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_help() ******
# 
#  NAME
#     check_option_help -- ??? 
#
#  SYNOPSIS
#     check_option_help { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_help {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-help"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 1
}

#                                                             max. column:     |
#****** qsub/check_option_hold_jid() ******
# 
#  NAME
#     check_option_hold_jid -- ??? 
#
#  SYNOPSIS
#     check_option_hold_jid { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_hold_jid {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-hold_jid 1,2,3"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   # test with job names
   set option "-hold_jid foo,bar"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_j_y() ******
# 
#  NAME
#     check_option_j_y -- ??? 
#
#  SYNOPSIS
#     check_option_j_y { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_j_y {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-j y"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0 "" "" 1
}

#                                                             max. column:     |
#****** qsub/check_option_j_n() ******
# 
#  NAME
#     check_option_j_n -- ??? 
#
#  SYNOPSIS
#     check_option_j_n { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_j_n {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-j n"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_l() ******
# 
#  NAME
#     check_option_l -- ??? 
#
#  SYNOPSIS
#     check_option_l { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_l {} {
   global ts_config
   global default_h_args

   # first clean up output directory:
   setup_output_directory

   # the default_h_args contain -l h=...
   set jobargs "$default_h_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_m() ******
# 
#  NAME
#     check_option_m -- ??? 
#
#  SYNOPSIS
#     check_option_m { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_m {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-m beas"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_notify() ******
# 
#  NAME
#     check_option_notify -- ??? 
#
#  SYNOPSIS
#     check_option_notify { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_notify {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-notify"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_now_yes() ******
# 
#  NAME
#     check_option_now_yes -- ??? 
#
#  SYNOPSIS
#     check_option_now_yes { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_now_yes {} {
   global ts_config
   global default_args job_output_dir

   # first clean up output directory:
   setup_output_directory

   set option "-now yes"
   set jobargs "$option $default_args"

   for {set i 1} {$i <= 3} {incr i 1} {
      set result [submit_job $jobargs 0]
      if {$result != -6} {
         break
      } else {
         ts_log_info "bugtraq id: 4938859 ->\nqsub -now yes returned job could not be scheduled, try later - error - trying again ... (try $i)"
         ts_log_fine "sleeping 5 sec ..."
         after 5000
      }
   }
 
   ts_log_fine "\njob $result has args: \"$jobargs\""

   if {$result < 0} {
      ts_log_severe "could not submit job\n -> return value of submit_job: $result"
      return
   }

   set time [expr [timestamp] + 300]

   while {[timestamp] < $time} {
      after 1000
      set back [was_job_running $result 0]
      if {$back != -1} {
         set back [del_job_files $result $job_output_dir 2]
         if {$back != 2} {
            ts_log_severe "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            return
         }
      }
   }
 
   ts_log_severe "timeout while waiting for job accounting"

   # negative test: expect job not to be scheduled
   # disable all queues
   #set result [submit_job $jobargs 0]
   #if {$result != -6} {
   #   ts_log_severe "qsub -now yes should have failed with all queues disabled"
   #}
   # enable all queues
}

#                                                             max. column:     |
#****** qsub/check_option_now_no() ******
# 
#  NAME
#     check_option_now_no -- ??? 
#
#  SYNOPSIS
#     check_option_now_no { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_now_no {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-now no"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_M() ******
# 
#  NAME
#     check_option_M -- ??? 
#
#  SYNOPSIS
#     check_option_M { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_M {} {
   global ts_config CHECK_REPORT_EMAIL_TO
   global default_args

   # can't run the check, if no email address has been configured
   if {[string compare $CHECK_REPORT_EMAIL_TO "none"] == 0} {
      ts_log_config "no email address configured - can't run qsub -M check"
      return
   }

   # first clean up output directory:
   setup_output_directory

   set option "-M $CHECK_REPORT_EMAIL_TO"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_N() ******
# 
#  NAME
#     check_option_N -- ??? 
#
#  SYNOPSIS
#     check_option_N { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_N {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   # positive tests
   foreach string [valid_job_has_valid_account_string "-N"] {
      set option "-N '$string'"
      set jobargs "$option $default_args"
      set job_id [qsub_submit_check $jobargs 0]

      if {$job_id > 0} {
         get_qacct $job_id
         set acct_string $qacct_info(jobname)
         if {$acct_string != $string} {
            ts_log_severe "job name string requested with -N option missing in accounting record:\nexpected $string, but accounting record contains $acct_string\nfor job $job_id"
         }
      }
   }

   # negative tests
   foreach string [invalid_job_has_valid_account_string "-N"] {
      set option "-N '$string'"
      set jobargs "$option $default_args"
      set job_id [qsub_submit_check $jobargs 1]
   }
}

#                                                             max. column:     |
#****** qsub/check_option_o() ******
# 
#  NAME
#     check_option_o -- ??? 
#
#  SYNOPSIS
#     check_option_o { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_o {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   # the default args already contain a -o option
   qsub_submit_check $default_args 0
}

#                                                             max. column:     |
#****** qsub/check_option_P() ******
# 
#  NAME
#     check_option_P -- ??? 
#
#  SYNOPSIS
#     check_option_P { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_P {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-P mytestproject"
   set jobargs "$option $default_args"
   set job_id [qsub_submit_check $jobargs 0]

   if {$job_id > 0} {
      get_qacct $job_id
      if {$qacct_info(project) != "mytestproject"} {
         ts_log_severe "project specified by -P switch missing in accounting record"
      }
   }
}

#                                                             max. column:     |
#****** qsub/check_option_p() ******
# 
#  NAME
#     check_option_p -- ??? 
#
#  SYNOPSIS
#     check_option_p { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_p {} {
   global ts_config CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER
   global default_args

   # first clean up output directory:
   setup_output_directory

   # test -p option:
   # any user must be allowed to submit with negative -p
   # only superuser may submit with positive -p

   # set as admin user: complete range
   qsub_submit_check "-p -1023 $default_args" 0 $CHECK_USER ;# IZ 2055
   qsub_submit_check "-p 0 $default_args" 0 $CHECK_USER
   qsub_submit_check "-p 1024 $default_args" 0 $CHECK_USER

   qsub_submit_check "-p -1024 $default_args" 1 $CHECK_USER
   qsub_submit_check "-p 1025 $default_args" 1 $CHECK_USER

   # test as non admin user: only negative .. 0
   qsub_submit_check "-p -100 $default_args" 0 $CHECK_FIRST_FOREIGN_SYSTEM_USER ;# IZ 2055
   qsub_submit_check "-p 0 $default_args" 0 $CHECK_FIRST_FOREIGN_SYSTEM_USER

   # Up to version 6.0, a positive priority from non operators will be silently 
   # set to 0 by qmaster.
   # Beginning with version 6.1, we will reject such jobs.
   qsub_submit_check "-p 1 $default_args" 1 $CHECK_FIRST_FOREIGN_SYSTEM_USER
}

#                                                             max. column:     |
#****** qsub/check_option_pe() ******
# 
#  NAME
#     check_option_pe -- ??? 
#
#  SYNOPSIS
#     check_option_pe { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_pe {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-pe mytestpe 1-3"
   set jobargs "$option $default_args"
   set job_id [qsub_submit_check $jobargs 0]

   if {$job_id > 0} {
      get_qacct $job_id
      if {$qacct_info(granted_pe) != "mytestpe"} {
         ts_log_severe "granted_pe missing in accounting record"
      }
      if {$qacct_info(slots) != 3} {
         ts_log_severe "slots incorrect in accounting record"
      }
   }
}

#                                                             max. column:     |
#****** qsub/check_option_q() ******
# 
#  NAME
#     check_option_q -- ??? 
#
#  SYNOPSIS
#     check_option_q { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_q {} {
   global ts_config
   global default_args test_host

   # first clean up output directory:
   setup_output_directory

   # submission to a queue instance (5.3 queue)
   set qinstance [get_queue_instance "all.q" $test_host]
   qsub_submit_check "-q $qinstance $default_args" 0

   # beginning with 6.0, we can also submit
   #  - to a cluster queue
   #  - to all queue instances on a host
   #  - to all qinstances of a hostgroup
   qsub_submit_check "-q *@${test_host} $default_args" 0
   qsub_submit_check "-q *@@allhosts $default_args" 0
}

#                                                             max. column:     |
#****** qsub/check_option_r_y() ******
# 
#  NAME
#     check_option_r_y -- ??? 
#
#  SYNOPSIS
#     check_option_r_y { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_r_y {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-r y"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_r_n() ******
# 
#  NAME
#     check_option_r_n -- ??? 
#
#  SYNOPSIS
#     check_option_r_n { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_r_n {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-r n"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_sc() ******
# 
#  NAME
#     check_option_sc -- ??? 
#
#  SYNOPSIS
#     check_option_sc { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_sc {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-sc myvar=test3"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_soft() ******
# 
#  NAME
#     check_option_soft -- ??? 
#
#  SYNOPSIS
#     check_option_soft { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_soft {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-soft"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_S() ******
# 
#  NAME
#     check_option_S -- ??? 
#
#  SYNOPSIS
#     check_option_S { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_S {} {
   global ts_config CHECK_USER CHECK_ACTUAL_TEST_PATH
   global default_args job_output_dir

   # first clean up output directory:
   setup_output_directory

   set option "-S /bin/sh"
   set jobargs "$option $default_args"
   if {[qsub_submit_check $jobargs 0] == 0} {
      ts_log_severe "Job with option -S /bin/sh failed!"
      return 1
   }

   # Special handling for Windows hosts, the shell can either be the Interix
   # shell (e.g. /bin/sh) or the Windows command processor
   # (e.g. C:\Windows\system32\cmd.exe).
   # The Interix shell is already tested with the general Unix test above, 
   # the Windows command processor is tested here:
   set windows_host ""
   if {[host_conf_have_windows]} {
      set windows_host [host_conf_get_windows_host]

      # The command processor is defined in the "COMSPEC" environment variable
      # on the Windows host. Read the value of the variable and convert the path
      # to Unix format, as qsub will only accept Unix style pathes for the
      # "-S" option.
      set windows_comspec_path [get_remote_env_value $windows_host "COMSPEC"]
      set windows_comspec_path [double_backslashes $windows_comspec_path]

      set unix_comspec_path [start_remote_prog $windows_host $CHECK_USER \
         "/bin/winpath2unix" "$windows_comspec_path" prg_exit_status 60 0 "" "" 1 1 1 1 1]
      set unix_comspec_path [string trimright $unix_comspec_path "\n\r"]

      # Check if retrieving and converting succeeded.
      if {$prg_exit_status != 0} {
         ts_log_severe "Can't convert Windows path of command processor (cmd.exe) to Unix format!\nCan't execute -S option test on Windows."
         return 1
      }
      if {[string length $unix_comspec_path] < 7} {
         ts_log_severe "Can't find Windows command processor (cmd.exe)\nCan't execute -S option test on Windows."
         return 1
      }

      set shell_option "-S $unix_comspec_path"
      set host_option "-l h=$windows_host"

      # First try to run a native Windows binary job with the given shell (cmd.exe) 
      set bin_option "-b y"
      set job_script "-o $job_output_dir -e $job_output_dir $CHECK_ACTUAL_TEST_PATH/worker.exe 5"
      set jobargs "$bin_option $shell_option $host_option $job_script"
      qsub_submit_check $jobargs 0

      # Then try to run a shell script with the given shell (cmd.exe) 
      set job_script "-o $job_output_dir -e $job_output_dir $CHECK_ACTUAL_TEST_PATH/hello.bat"
      set jobargs "$shell_option $host_option $job_script"
      qsub_submit_check $jobargs 0
   }
}

#                                                             max. column:     |
#****** qsub/check_option_t() ******
# 
#  NAME
#     check_option_t -- ??? 
#
#  SYNOPSIS
#     check_option_t { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_t {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   # positive tests
   set option "-t 2-8:2"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0 "" "" 8
 
   # negative test:
   set option "-t 1-2:-1"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 1

   set option "-t 1-2:xx"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 1

   set option "-t 1-500000"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 1
}

#                                                             max. column:     |
#****** qsub/check_option_verify() ******
# 
#  NAME
#     check_option_verify -- ??? 
#
#  SYNOPSIS
#     check_option_verify { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_verify {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-verify"
   set jobargs "$option $default_args"

   # cannot use submit_job - it would fail on -verify
   set output [start_sge_bin "qsub" $jobargs]

   # expect certain output:
   set found 0
   foreach line [split $output "\n"] {
      if {[string match "job_number:*unassigned*" $line]} {
         set found 1
         break
      }
   }

   if {!$found} {
      ts_log_severe "no verify output on -verify command:\n$output"
   }
}

#                                                             max. column:     |
#****** qsub/check_option_V() ******
# 
#  NAME
#     check_option_V -- ??? 
#
#  SYNOPSIS
#     check_option_V { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_V {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-V"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_@() ******
# 
#  NAME
#     check_option_@ -- ??? 
#
#  SYNOPSIS
#     check_option_@ { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_@ {} {
   global ts_config CHECK_ACTUAL_TEST_PATH
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-@ $CHECK_ACTUAL_TEST_PATH/commandfile.txt"
   set jobargs "$option $default_args"
   set result [submit_job $jobargs 0]

   if {$result != -2} {
      ts_log_severe "no help output on -@ commandfile option"
   }
}

#                                                             max. column:     |
#****** qsub/check_huge_script() ******
# 
#  NAME
#     check_huge_script -- ??? 
#
#  SYNOPSIS
#     check_huge_script { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_huge_script {} {
   global ts_config CHECK_PROTOCOL_DIR
   global job_output_dir test_host CHECK_USER
   global HUGE_SCRIPT_SIZE HUGE_SCRIPT_PATTERN HUGE_SCRIPT_TIMEOUT steps_per_queue size_interval

   # first clean up output directory:
   setup_output_directory

   # protocol
   set protocol_filename "$CHECK_PROTOCOL_DIR/qsub_huge_script.txt"
   set protocol [open $protocol_filename "w"]
   puts $protocol "submitting huge scripts"
   puts $protocol "size       = size of the script"
   puts $protocol "submittime = time needed to submit the script, timeout after $HUGE_SCRIPT_TIMEOUT s"
   puts $protocol "schedtime  = time the job needs to startup"
   puts $protocol "runtime    = runtime of the job"
   puts $protocol ""
   puts $protocol "size\tsubmittime\tschedtime\truntime"
   flush $protocol

   for {set step 0} {$step < $steps_per_queue} {incr step} {
      # create a huge sleeper.sh
      set filename "$job_output_dir/sleeper.sh"
      file copy -force "$ts_config(product_root)/examples/jobs/sleeper.sh" "$filename"
      set f [open $filename a]
      puts $f "exit 0"
      set times [expr $size_interval * $step / [string length $HUGE_SCRIPT_PATTERN]]
      for {set i 0} {$i < $times} {incr i} {
         puts $f "$HUGE_SCRIPT_PATTERN"
      }
      close $f
   
      wait_for_remote_file $test_host $CHECK_USER $filename
      set submit_size [file size $filename]
      ts_log_fine "submitting job script of size $submit_size bytes allowing a timeout of $HUGE_SCRIPT_TIMEOUT s"
   
      set jobargs "-l h=${test_host} -o $job_output_dir -e $job_output_dir $filename 5"
      set submit_start [clock seconds]
      set result [submit_job $jobargs 1 $HUGE_SCRIPT_TIMEOUT]
      if {$result < 0} {
         ts_log_severe "could not submit job (result: $result)"
         close $protocol
         return
      } else {
         set sched_start [clock seconds]
         set submit_time [expr $sched_start - $submit_start]
         ts_log_fine "submitting lasted $submit_time s"
         wait_for_jobstart $result "Sleeper" $HUGE_SCRIPT_TIMEOUT
         set run_start [clock seconds]
         set sched_time [expr $run_start - $sched_start]
         wait_for_jobend $result "Sleeper" $HUGE_SCRIPT_TIMEOUT 0
         set run_end [clock seconds]
         set run_time [expr $run_end - $run_start]
         puts $protocol "$submit_size\t$submit_time\t$sched_time\t$run_time"
         flush $protocol
      }

      file delete $filename

      set back [del_job_files $result $job_output_dir 2]
      if {$back != 2} {
         ts_log_severe "job $result did not produce error and output file\njobargs: $jobargs"
         close $protocol
         return
      }
   }

   close $protocol
}
#
#
#****** qsub/check_qsub_ts_iz_72() ***********************************************
#  NAME
#     check_qsub_ts_iz_72() -- Testcase for TS IZ 72.
#
#  SYNOPSIS
#     1. submit an array job in hold
#     2. qalter one task into system hold
#     3. qalter one task into pending state
#     4. wait until the task has finsihed
#     5. check, if the task in system hold is still there.
#
#  FUNCTION
#     Check if TS IZ 72 has been fixed.
#  INPUTS
#
#*******************************************************************************
proc check_qsub_ts_iz_72 {} {
	global ts_config

   # Delete any remaining jobs
   delete_all_jobs
      
   # 1. submit an array job in hold
   submit_job "-h -t 1-2 -o /dev/null -j y -N TS_IZ_72 $ts_config(product_root)/examples/jobs/sleeper.sh 15"
	
   # Get the jobid with qstat_plain_parse
   # qstat_plain_output contains the plain qstat output in an assoc. array
   # qstat_plain_output(jobid) contains a list of jobids.
   qstat_plain_parse qstat_plain_output
   ts_log_fine "qstat array ..."
   parray qstat_plain_output

   # Now let's compare them by jobid. 
   set jobid_list $qstat_plain_output(index)
	set jobid [lindex $jobid_list 0]
   ts_log_fine "get the jobid ..."
	
   # 2. qalter one task into system hold
   start_sge_bin "qalter" "-h s $jobid.1"
	
   # 3. qalter one task into pending state
   start_sge_bin "qalter" "-h n $jobid.2"
	
   # 4. wait until the task has finished
   # TODO: wait_for_end_of_task ???
   # TODO: I don't understand this test at all!
   trigger_scheduling

   set my_timeout [timestamp]
   incr my_timeout 60
   while { [timestamp] < $my_timeout } {
      set states [get_job_state $jobid 1 task_id]
      set nr_of_tasks [llength $states]
      for {set i 0} {$i < $nr_of_tasks} {incr i 1} {
         ts_log_fine "task $task_id($i,task) state is \"$task_id($i,state)\""
      }
      if {$nr_of_tasks == 1} { 
         ts_log_fine "task 2 finished"
         break
      }
      after 2500
   }

   after 5000   ;# wait some extra time
	
   # 5. check, if the task in system hold is still there.
   qstat_plain_parse qstat_plain_output1
      
   ts_log_fine "qstat array at the end .... \n"
   parray qstat_plain_output1
	
	if {$qstat_plain_output1($jobid,state) != "hqw"} {
		ts_log_severe "Task 2 not in hold state"
	} elseif {$qstat_plain_output1($jobid,jatask) == "2"} {
		ts_log_severe "Task 2 is still around"
	} elseif {$qstat_plain_output1($jobid,jatask) == "1,2"} {
		ts_log_severe "Task 2 was never scheduled"
	} elseif {[llength $qstat_plain_output1($jobid,jatask)] == 2} {
	   ts_log_severe "Task 2 is still around"
	} else {
		ts_log_fine "Task in system hold is still around as expected"
	} 
	
	delete_all_jobs
   wait_for_end_of_all_jobs
}

proc check_qhold_jobname {} {
   global ts_config
   global CHECK_FIRST_FOREIGN_SYSTEM_USER
   global job_output_dir test_host

   # first clean up output directory:  
   setup_output_directory

   # submit jobs, second one depends on FIRST one
   set jobargs "-h -l h=${test_host} -N FIRST -o $job_output_dir -e $job_output_dir $ts_config(product_root)/examples/jobs/sleeper.sh 90" 
   set hold_job1 [submit_job $jobargs] 

   set jobargs "-hold_jid FIRST -l h=${test_host} -o $job_output_dir -e $job_output_dir $ts_config(product_root)/examples/jobs/sleeper.sh 30" 
   set hold_job2 [submit_job $jobargs] 

   # wait for jobs to get in pending state
   wait_for_jobpending $hold_job1 "FIRST" 200
   wait_for_jobpending $hold_job2 "Sleeper" 200 

   # job 1 should not run within the next 60 seconds  (user hold)
   if {[wait_for_jobstart $hold_job1 "Sleeper" 60 0] != -1} {
      ts_log_severe "job $hold_job1 should not run until yet(1)"
   }

   # release job 1
   release_job $hold_job1
   wait_for_jobstart $hold_job1 "FIRST" 100

   # job 2 should not run within the next minute (dependency)
   if {[wait_for_jobstart $hold_job2 "Sleeper" 60 0] != -1} {
      ts_log_severe "job $hold_job2 should not run until yet(2)"
   }

   # job1 will stop in ca. 30 sec
   wait_for_jobend $hold_job1 "FIRST" 100 0

   # job2 should run now
   wait_for_jobstart $hold_job2 "Sleeper" 100

   # job2 should run till end
   wait_for_jobend $hold_job2 "Sleeper" 100 0

   set back [del_job_files $hold_job1 $job_output_dir 2]
   if {$back != 2} {
      ts_log_severe "job $hold_job1 did not produce error and output file"
   }

   set back [ del_job_files $hold_job2 $job_output_dir 2 ] 
   if { $back != 2 } {
      ts_log_severe "job $hold_job2 did not produce error and output file"
   }

   ts_log_fine "Test wait for not existent job (job should immediately run)"
   set jobargs "-hold_jid FIRST -l h=${test_host} -o /dev/null -e /dev/null $ts_config(product_root)/examples/jobs/sleeper.sh 30"
   set job_id [submit_job $jobargs]
   wait_for_jobstart $job_id "Sleeper" 60
   wait_for_jobend $job_id "Sleeper" 60 0

   ts_log_fine "additional job submit with same name test"
   set jobargs "-h -l h=${test_host} -N FIRST -o /dev/null -e /dev/null $ts_config(product_root)/examples/jobs/sleeper.sh 30"
   set hold_job1 [submit_job $jobargs]

   ts_log_fine "additional job submit with same name test"
   set jobargs "-h -l h=${test_host} -N FIRST -o /dev/null -e /dev/null $ts_config(product_root)/examples/jobs/sleeper.sh 30"
   set hold_job2 [submit_job $jobargs]

   wait_for_jobpending $hold_job1 "FIRST" 60
   wait_for_jobpending $hold_job2 "FIRST" 60

   set jobargs "-hold_jid FIRST -l h=${test_host} -o /dev/null -e /dev/null $ts_config(product_root)/examples/jobs/sleeper.sh 30"
   set hold_job3 [submit_job $jobargs 0]
   if {$hold_job3 <= 0} {
      ts_log_severe "job $hold_job3 should depend on multiple jobs, selected by name"
   } else {
      ts_log_fine "submitted job with multiple predecessors selected by job name: $hold_job3 - correct"
   } 
    
   delete_job $hold_job1

   ts_log_fine "submitting hold job ..."
   set jobargs "-hold_jid FIRST -l h=${test_host} -o /dev/null -e /dev/null $ts_config(product_root)/examples/jobs/sleeper.sh 30" 
   set hold_job3 [submit_job $jobargs]

   ts_log_fine "submitting job with same name (FIRST) ..."
   set jobargs "-h -l h=${test_host} -N FIRST -o /dev/null -e /dev/null $ts_config(product_root)/examples/jobs/sleeper.sh 30"
   ts_log_fine $jobargs
   set hold_job1 [submit_job $jobargs 0]
   if {$hold_job1 <= 0} {
      ts_log_severe "job $hold_job1 should have been submitted - -N name is ok, even if job dependencies containing this name exist"
   } else {
      ts_log_fine "could submit job reusing jobname that is in use in a job dependency: $hold_job1 - correct"
   }

   delete_job $hold_job1
   delete_job $hold_job2
   delete_job $hold_job3

   # test foreign user influence ...
   ts_log_fine "checking hold for foreign user ..."
   ts_log_fine "submitting job with same name (FIRST) as user $CHECK_FIRST_FOREIGN_SYSTEM_USER ..."
   set jobargs "-h -l h=${test_host} -N FIRST -o /dev/null -e /dev/null $ts_config(product_root)/examples/jobs/sleeper.sh 30"
   ts_log_fine $jobargs
   set hold_job1 [submit_job $jobargs 1 30 "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]

   ts_log_fine "submitting hold job ..."
   set jobargs "-hold_jid FIRST -l h=${test_host} -o /dev/null -e /dev/null $ts_config(product_root)/examples/jobs/sleeper.sh 30"
   set hold_job3 [submit_job $jobargs]

   wait_for_jobstart $hold_job3 "Sleeper" 75
   wait_for_jobend $hold_job3 "Sleeper" 75 0

   ts_log_fine "additional job submit with same name test"
   set jobargs "-h -l h=${test_host} -N FIRST -o /dev/null -e /dev/null $ts_config(product_root)/examples/jobs/sleeper.sh 30"
   set hold_job2 [submit_job $jobargs]

   ts_log_fine "submitting hold job ..."
   set jobargs "-hold_jid FIRST -l h=${test_host} -o /dev/null -e /dev/null $ts_config(product_root)/examples/jobs/sleeper.sh 30"
   set hold_job3 [submit_job $jobargs]

   if {[wait_for_jobstart $hold_job3 "Sleeper" 60 0] != -1} {
      ts_log_severe "job $hold_job3 should not run until yet(3)"
   }

   delete_job $hold_job3
   delete_job $hold_job2
 
   release_job $hold_job1
   wait_for_jobstart $hold_job1 "FIRST" 60
   wait_for_jobend $hold_job1 "FIRST" 60 0
}

#                                                             max. column:     |
#****** qsub/check_option_v() ******
# 
#  NAME
#     check_option_v -- ??? 
#
#  SYNOPSIS
#     check_option_v { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_v {} {
   global ts_config
   global job_output_dir test_host

   # first clean up output directory:
   setup_output_directory

   set option "-v DISPLAY,test_var1=hello=world,test_var2=hello=my=friend"
   set jobargs "$option -l h=${test_host} -o $job_output_dir -e $job_output_dir $ts_config(product_root)/examples/jobs/sleeper.sh 5"

   set result [submit_job $jobargs 0]
   ts_log_fine "\njob $result has args: \"$jobargs\""

   if {$result < 0} {
      ts_log_severe "could not submit job"
      return
   }

   # check if the environment variables are set correctly in the job object
   set qstat_out [start_sge_bin qstat "-j"]
   if {[string match *DISPLAY*,test_var1=hello=world,test_var2=hello=my=friend* $qstat_out] == -1} {
      ts_log_severe "-v option failed, equal sign within variable values not supported"
   }

   # JG: TODO: instead of starting the example sleeper job, we should output the environment in the job. 
   # Then we could check, if the passed environment variables are really set in the job environment.
   # CR: Don't we have already a test for checking the job environment? We can do this in the job_environment test!

   set time [expr [timestamp] + 300]
   while {[timestamp] < $time} {
      after 1000
      set back [was_job_running $result 0]
      if {$back != -1} {
         set back [del_job_files $result $job_output_dir 2]
         if {$back != 2} {
            ts_log_severe "job $result did not produce error and output file\njobargs: $jobargs"
         }
         return
      }
   }
 
   ts_log_severe "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_sync() ******
# 
#  NAME
#     check_option_sync -- ??? 
#
#  SYNOPSIS
#     check_option_sync { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_sync {} {
   global ts_config
   global job_output_dir test_host

   # first clean up output directory:  
   setup_output_directory

   set option "-sync y"
   set jobargs "$option -o /dev/null -e /dev/null -j y $ts_config(testsuite_root_dir)/scripts/qsub_exit.sh 5" 
   set result [start_sge_bin "qsub" $jobargs]
   ts_log_fine "\njob has args: \"$jobargs\""
   ts_log_fine "exit code: $prg_exit_state"
   if {$prg_exit_state != 5} {
      ts_log_severe "qsub did not exit with correct exit code: $result"
   }
}

#                                                             max. column:     |
#****** qsub/check_option_sync_t() ******
# 
#  NAME
#     check_option_sync_t -- ??? 
#
#  SYNOPSIS
#     check_option_sync_t { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_sync_t {} {
   global ts_config
   global job_output_dir test_host

   # first clean up output directory:  
   setup_output_directory

   set option "-sync y -t 1-2"
   set jobargs "$option -o /dev/null -e /dev/null -j y $ts_config(testsuite_root_dir)/scripts/qsub_exit.sh 5"
   set result [start_sge_bin "qsub" "$jobargs"]
   ts_log_fine "\njob $result has args: \"$jobargs\""
   ts_log_fine "exit state: $prg_exit_state"
   if {$prg_exit_state != 5} {
      ts_log_severe "qsub did not exit with correct exit code: $result"
   }
}

proc invalid_job_has_valid_account_string {option} {
   set ret {}

   lappend ret "test\ntest"
   lappend ret "test\ttest"
   lappend ret "test\rtest"
   lappend ret "test/test"
   lappend ret "test:test"
   lappend ret "test@test"
   lappend ret "test\\test"
   lappend ret "test*test"
   lappend ret "test?test"

   if {$option == "-N"} {
      lappend ret "1test"
   }

   return $ret
}

proc valid_job_has_valid_account_string {option} {
   set ret {}

   lappend ret "test"
   lappend ret "test test"
   lappend ret "test!test"
   lappend ret "test,test"
   lappend ret "test;test"
   lappend ret "test.test"
   lappend ret "testäöüßtest"
   lappend ret "test=test"
   lappend ret "test%test"
   lappend ret "test|test"
   lappend ret "\"test\""

   if {$option == "-A"} {
      lappend ret "1test"
   }

   return $ret
}

#                                                             max. column:     |
#****** qsub/check_option_terse() ******
# 
#  NAME
#     check_option_terse -- Check to see if the terse option works
#
#  SYNOPSIS
#     check_option_terse { } 
#
#  FUNCTION
#     The function tries to submit a job with -terse option to see if it throws
#     only the job id in case of successfull job submission.
#     It further check to verify if the -terse is working by,
#     -  checks to see if the result of start_sge_bin throws the o/p starting
#       with "Your job", if yes then the option is not working.
#     -  checks to see if the result when passed to get_extended_job_info as
#       job-id gives positive result
#
#  INPUTS
#     NONE
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     qsub -terse sleeper.sh
#
#  NOTES
#     This is for RFE 6355875 
#     "-terse" that would have qsub just display the job number, and none of the
#     '[Yy]our job number...' stuff.
#
#     If there are errors, they should continue to be submitted via stderr.
#
#     Thus, the output of qsub would look like:
#
#     $ qsub -terse -cwd -t 1:5 ./runme.sh
#     1321772.1-5:1
#
#     $ qsub -terse -cwd ./runme.sh
#     1321775
#
#     If the user doesn't specify '-terse' the behaviour should be the same as it is
#     today.
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************

proc check_option_terse {} {
   global ts_config
   global default_args

   ts_log_fine "Testing qsub -terse option"
   set job_args "-o /dev/null -e /dev/null -terse $default_args"
   set output ""
   set not_expected [translate_macro MSG_QSUB_YOURJOBHASBEENSUBMITTED_SS "*" "*"]
   ts_log_fine "Running qsub -terse option: $job_args"
   set output [start_sge_bin "qsub" $job_args]
   # now check if the output contained "Your job ", which means the option is not
   # working
   # Do a second check to see if the job has been submitted, and $output has jobid
   if {$prg_exit_state == 0} {
      if {[string first $not_expected $output] == 0 && [get_extended_job_info $output] == 1} {
         ts_log_severe "not working:\n$output"
      } else {
         ts_log_fine "The -terse is working!!!!\n$output)"
      }
   } else {
      ts_log_severe "qsub $job_args failed:\n$output"
   }
}

#                                                             max. column:     |
#****** qsub/check_deadline() ******
# 
#  NAME
#     check_deadline -- ??? 
#
#  SYNOPSIS
#     check_deadline { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_deadline {} {
   global ts_config
   global test_host job_output_dir

   if {$ts_config(product_type) == "sge"} {
      ts_log_config "not possible in sge system"
      return
   }

   # get command option string 
   set then [clock scan "1 minute"]
   set deadline [clock format $then -format "%Y%m%d%H%M.%S"]

   # deadline job (2 min) with deadline in 1 minutes
   set jobargs "-dl $deadline -l h=${test_host} -o $job_output_dir -e $job_output_dir $ts_config(product_root)/examples/jobs/sleeper.sh 120"
   # start job
   set job_id [submit_job $jobargs]
   if {$job_id < 0} {
      ts_log_severe "could not submit job"
      return
   }

   # now job is in queueing system (get timestamp now)
   ts_log_fine "monitoring job $job_id"

   set dlcontr_min 999999999
   set dlcontr_max 0
   while {[get_urgency_job_info ""] == 1 && $job_info(index) == $job_id} {
      set dlcontr $job_info($job_id,dlcontr)
      ts_log_fine "job has deadline $job_info($job_id,deadline), dlcontr $dlcontr"
      if {$dlcontr < $dlcontr_min} {
         set dlcontr_min $dlcontr
      }
      if {$dlcontr > $dlcontr_max} {
         set dlcontr_max $dlcontr
      }
      after 5000
   }

   # now the job is done - delete job files
   set back [del_job_files $job_id $job_output_dir 2]
   if {$back != 2} {
      ts_log_severe "job $job_id did not produce error and output file"
   }

   # and now analyze the deadline policy info
   get_schedd_config schedd_config

   ts_log_fine "minimum dlcontr was $dlcontr_min"
   ts_log_fine "maximum dlcontr was $dlcontr_max"
   ts_log_fine "weight_deadline is  $schedd_config(weight_deadline)"

   if {$dlcontr_min != 0} {
      ts_log_severe "expected a minimum dlcontr of 0, but got $dlcontr_min"
   }
   if {$dlcontr_max != $schedd_config(weight_deadline)} {
      ts_log_severe "expected a maximum dlcontr of $schedd_config(weight_deadline), but got $dlcontr_max"
   }
}

#****** qsub/qsub_wd() ******
#
#  NAME
#     qsub_wd -- test if -wd/-cwd work
#
#  SYNOPSIS
#     qsub_wd { }
#
#*******************************
proc qsub_wd {} {
   global ts_config

   # Set a directory
   set wdir "/tmp"
   set cwdir [pwd]

   # Test1 -wd $wdir
   set jobargs "-h -wd $wdir -o /dev/null -j y $ts_config(product_root)/examples/jobs/sleeper.sh 90"
   set hold_job1 [submit_job $jobargs 1 60 "" "" $cwdir 1]
   get_qstat_j_info $hold_job1
   if {[string compare "$qstat_j_info(cwd)" "$wdir"] != 0} {
      set error_text "qsub did not set the correct working dir(1): $wdir != $qstat_j_info(cwd)\n"
      ts_log_severe $error_text
   }
   delete_job $hold_job1

   # Test2 -cwd
   set jobargs "-h -cwd -o /dev/null -j y $ts_config(product_root)/examples/jobs/sleeper.sh 90"
   set hold_job1 [submit_job $jobargs 1 60 "" "" $cwdir 1]
   get_qstat_j_info $hold_job1
   # we do a string match because of possible automounter prefixes (e.g. /tmp_mnt)
   # cwdir MUST be part of reported working dir (at least from the left side)
   if {![string match "*$cwdir" $qstat_j_info(cwd)]} {
      set error_text "qsub did not set the correct working dir(2): $cwdir != $qstat_j_info(cwd)\n"
      ts_log_severe $error_text
   }
   delete_job $hold_job1

   # Test3 -cwd -wd $wdir
   set jobargs "-h -cwd -wd $wdir -o /dev/null -j y $ts_config(product_root)/examples/jobs/sleeper.sh 90"
   set hold_job1 [submit_job $jobargs 1 60 "" "" $cwdir 1]
   get_qstat_j_info $hold_job1
   if {[string compare "$qstat_j_info(cwd)" "$wdir"] != 0} {
      set error_text "qsub did not set the correct working dir(3): $wdir != $qstat_j_info(cwd)\n"
      ts_log_severe $error_text
   }
   delete_job $hold_job1

   # Test4 -wd $wdir -cwd
   set jobargs "-h -wd $wdir -cwd -o /dev/null -j y $ts_config(product_root)/examples/jobs/sleeper.sh 90"
   set hold_job1 [submit_job $jobargs 1 60 "" "" $cwdir 1]
   get_qstat_j_info $hold_job1

   # we do a string match because of possible automounter prefixes (e.g. /tmp_mnt)
   # cwdir MUST be part of reported working dir (at least from the left side)
   if {![string match "*$cwdir" $qstat_j_info(cwd)]} {
      set error_text "qsub did not set the correct working dir(4): $cwdir != $qstat_j_info(cwd)\n"
      ts_log_severe $error_text
   }
   delete_job $hold_job1
   wait_for_end_of_all_jobs
}


#****** qsub/check_qsub_ts_iz_145() ***********************************************
#  NAME
#     check_qsub_ts_iz_145() -- Testcase for TS IZ 145.
#
#  SYNOPSIS
#     1. Run qsub -t 1-100:100 -cwd sleep.sh
#     2. Check that  the output file looks correct
#        This file will be in the local dir, called
#        sleep.sh.o<jobid>.1
#     3 Repeat for qsub -t 1-95:100 -cwd sleep.sh
#     4.Repeat for qsub -t 1-100:50 -cwd sleep.sh
#        In this case, we have TWO output files,
#        sleep.sh.o<jobid>.1 and sleep.sh.o<jobid>.51
#     5. Repeat for qsub -t 1-100:50 -cwd sleep.sh
#
#  FUNCTION
#     Check if TS IZ 145 has been fixed.
#  INPUTS
#
#*******************************************************************************
proc check_qsub_ts_iz_145 {} {

   # Call with -t 1-100:100
   set SGE_TASK_FIRST 1
   set SGE_TASK_LAST 100
   set SGE_TASK_STEPSIZE 100

   qsub_ts_iz_145 $SGE_TASK_FIRST $SGE_TASK_LAST $SGE_TASK_STEPSIZE

   # Call with -t 1-95:100
   set SGE_TASK_FIRST 1
   set SGE_TASK_LAST 95
   set SGE_TASK_STEPSIZE 100

   qsub_ts_iz_145 $SGE_TASK_FIRST $SGE_TASK_LAST $SGE_TASK_STEPSIZE

   # Call with -t 1-100:50
   set SGE_TASK_FIRST 1
   set SGE_TASK_LAST 100
   set SGE_TASK_STEPSIZE 50

   qsub_ts_iz_145 $SGE_TASK_FIRST $SGE_TASK_LAST $SGE_TASK_STEPSIZE

   # Call with -t 1-95:50
   set SGE_TASK_FIRST 1
   set SGE_TASK_LAST 95
   set SGE_TASK_STEPSIZE 50

   qsub_ts_iz_145 $SGE_TASK_FIRST $SGE_TASK_LAST $SGE_TASK_STEPSIZE
}

proc qsub_ts_iz_145 { {t_sge_task_first "1"} {t_sge_task_last "4"}
                      {t_sge_task_stepsize "4" } } {
   global ts_config env
   global CHECK_USER CHECK_ACTUAL_TEST_PATH

   set SGE_TASK_FIRST $t_sge_task_first
   set SGE_TASK_LAST $t_sge_task_last
   set SGE_TASK_STEPSIZE $t_sge_task_stepsize

   set host $ts_config(master_host)
   set output_tmpfile [get_tmp_file_name]

   # Delete any remaining jobs
   delete_all_jobs

	#1. First submit
   set job_id [submit_job "-t $SGE_TASK_FIRST-$SGE_TASK_LAST:$SGE_TASK_STEPSIZE -o $output_tmpfile -e /dev/null $CHECK_ACTUAL_TEST_PATH/step.sh"]
   trigger_scheduling

   # Sleep until the jobs are finished
   wait_for_jobend $job_id "step" 10 0

   set result [start_remote_prog $host $CHECK_USER cat $output_tmpfile exit_code]
   # echo first $SGE_TASK_FIRST last $SGE_TASK_LAST step $SGE_TASK_STEPSIZE
   # ts_log_fine "result is \n $result"

   if {$exit_code != 0 || $result == ""} {
      ts_log_severe "error reading from output file on host $host:\n$result"
   } else {
      if {[scan $result "first  %d last %d step %d" sge_task_first sge_task_last sge_task_stepsize] != 3 } {
         ts_log_severe "error parsing output file from host $host:\n$result"
      } else {
         # sge_task_first should be $SGE_TASK_FIRST
         if {$sge_task_first != $SGE_TASK_FIRST} {
            ts_log_severe "SGE_TASK_FIRST is incorrect:\n$sge_task_first, expected $SGE_TASK_FIRST"
         } else {
            ts_log_fine "SGE_TASK_FIRST is $sge_task_first \n"
         }

         # sge_task_last should be $SGE_TASK_LAST
         if {$sge_task_last != $SGE_TASK_LAST} {
            ts_log_severe "SGE_TASK_LAST is incorrect:\n$sge_task_last, expected $SGE_TASK_LAST"
         } else {
            ts_log_fine "SGE_TASK_LAST is $sge_task_last \n"
         }

         # sge_task_stepsize should be $SGE_TASK_STEPSIZE
         if {$sge_task_stepsize != $SGE_TASK_STEPSIZE} {
            ts_log_severe "SGE_TASK_STEPSIZE is incorrect:\n$sge_task_stepsize, expected $SGE_TASK_STEPSIZE"
         } else {
            ts_log_fine "SGE_TASK_STEPSIZE is $sge_task_stepsize \n"
         }
      }
   }

   #clean up
   file delete $output_tmpfile
}

#****** check.61/check_sync_failover() *****************************************
#  NAME
#     check_sync_failover() -- Testcase for TS IZ 3
#
#  SYNOPSIS
#     1. Qmaster down before qsub -sync y
#     2. Qmaster down after qsub -sync y
#     3. qconf -km after qsub -sync y
#     4. qconf -kec after qsub -sync y
#
#  FUNCTION
#     Checks the qsub-output of the in synapsis described scenarios
#
#  BUGS
#     TS IZ 3
#     TS 2934
#
#*******************************************************************************
proc check_sync_failover {} {
   global ts_config
   global CHECK_USER

   # Delete any remaining jobs
   delete_all_jobs

   set SUBMIT_MESSAGE "*[translate_macro MSG_JOB_SUBMITJOB_US "*" "*"]*"

   set spool_dir [get_spool_dir $ts_config(master_host) "qmaster"]
   set host $ts_config(master_host)
   set arch [resolve_arch $host]
   set error_text ""
   set error 0
   set timeout 120

   # qconf -km before qsub -sync y
   shutdown_master_and_scheduler $ts_config(master_host) $spool_dir
   set output [start_sge_bin "qsub" "-sync y $ts_config(product_root)/examples/jobs/sleeper.sh 10" $host $CHECK_USER]
   set text [translate_macro MSG_GDI_UNABLE_TO_CONNECT_SUS "qmaster" "*" "*"]
   set text2 [translate_macro MSG_GDI_CANT_SEND_MSG_TO_PORT_ON_HOST_SUSS "qmaster" "*" "*" "*"]
   if {[string match "*$text*" $output] == 0 && [string match "*$text2*" $output] == 0} {
      append error_text "\"qconf -km before qsub -sync y\" FAILED due to an unexpected output\n"
      set error 1
   }
   startup_qmaster 1

   # qconf -km after qsub -sync y
   set id [open_remote_spawn_process $host $CHECK_USER "$ts_config(product_root)/bin/$arch/qsub" "-sync y $ts_config(product_root)/examples/jobs/sleeper.sh 30"]
   set sp_id [lindex $id 1]

   expect {
      -i $sp_id timeout {
         append error_text "Timeout in \"Qmaster down after qsub -sync y\" test\n"
         set error 1
      }
      -i $sp_id eof {
         append error_text "Unexpected EOF in \"Qmaster down after qsub -sync y\" test\n"
         set error 1
      }
      # The qmaster has become unreachable
      -i $sp_id -- $SUBMIT_MESSAGE {
         ts_log_fine "Qsub output: job submitted"
      }
      "_END_OF_FILE_" {
         set error 1
         append error_text "Could not submit job to qmaster\n"
         append error_text "$expect_out(buffer)\n"
      }
   }
   wait_for_event_client "qsub"
   set output 0
   set recon 0
   set text [translate_macro MSG_JAPI_QMASTER_DOWN]
   set text2 [translate_macro MSG_JAPI_RECONNECTED]
   shutdown_master_and_scheduler $ts_config(master_host) $spool_dir
   set timeout 660  ;# reconnect time might take some time
   # (TODO: reconfigure delayed job reporting time for execd somehow to speedup this test)
   ts_log_fine "now waiting for qsub -sync job finished (this might take up to 10 minutes)"
   expect {
      -i $sp_id timeout {
         append error_text "Timeout in \"qconf -km after qsub -sync y\" test\n"
         set error 1
      }
      -i $sp_id eof {
         append error_text "Unexpected EOF in \"qconf -km after qsub -sync y\" test\n"
         set error 1
      }
      # The qmaster has gone down.  Waiting to reconnect.error:
      -i $sp_id -- $text {
         ts_log_fine "Qsub output: The qmaster has gone down."
         set output 1
         if {[startup_qmaster 1] != 0} {
            ts_log_severe "qmaster could not be started"
         }
         exp_continue
      }
      # Reconnected to qmaster
      -i $sp_id -- $text2 {
         ts_log_fine "Qsub output: Reconnected to qmaster."
         set recon 1
         exp_continue
      }
      -i $sp_id -- "*_END_OF_FILE_" {
         ts_log_fine "$expect_out(buffer)"
         ts_log_fine "qsub -sync job finished"
      }
   }
   close_spawn_process $id

   if {$output != 1} {
      append error_text "\"qconf -km after qsub -sync y\" FAILED due to an unexpected output\n"
      set error 1
   }
   if {$recon != 1} {
      append error_text "\"qconf -km after qsub -sync y\" FAILED because the event client was unable to reconnect\n"
      set error 1
   }


   del_event_client_list "all" ""
   wait_for_event_client "qsub" 1


   # qconf -kec after qsub -sync y
   set id [open_remote_spawn_process $host $CHECK_USER "$ts_config(product_root)/bin/$arch/qsub" "-sync y $ts_config(product_root)/examples/jobs/sleeper.sh 120"]
   set sp_id [lindex $id 1]
   set timeout 120
   expect {
      -i $sp_id timeout {
         append error_text "Timeout in \"Qmaster down after qsub -sync y\" test\n"
         set error 1
      }
      -i $sp_id eof {
         append error_text "Unexpected EOF in \"Qmaster down after qsub -sync y\" test\n"
         set error 1
      }
      # The qmaster has become unreachable
      -i $sp_id -- $SUBMIT_MESSAGE {
         ts_log_fine "Qsub output: job submitted"
      }
      "_END_OF_FILE_" {
         set error 1
         append error_text "Could not submit job to qmaster\n"
         append error_text "$expect_out(buffer)\n"
      }
   }
   wait_for_event_client "qsub"
   set output 0
   set found_eof 0
   set text [translate_macro MSG_JAPI_KILLED_EVENT_CLIENT]
   del_event_client_list "all" ""
   expect {
      -i $sp_id timeout {
         append error_text "Timeout in \"qconf -kec after qsub -sync y\" test\n"
         set error 1
      }
      -i $sp_id eof {
         append error_text "Unexpected EOF in \"qconf -kec after qsub -sync y\" test\n"
         set error 1
      }
      # Unable to wait for job because of error: Event client got shutdown signal
      -i $sp_id -- $text {
         ts_log_fine "Qsub output: Unable to wait for job because of error:  Event client got shutdown signal"
         set output 1
         exp_continue
      }
      "_END_OF_FILE_" {
         set found_eof 1
         ts_log_fine "found end of file of qsub -sync script"
      }
   }
   close_spawn_process $id
   if {$output != 1} {
      append error_text "\"qconf -kec after qsub -sync y\" FAILED due to an unexpected output\n"
      set error 1
   }

   if {$found_eof != 1} {
      append error_text "\"qconf -kec after qsub -sync y\" FAILED because qsub doesn't terminate\n"
      set error 1
   }
   delete_all_jobs
   wait_for_end_of_all_jobs
   wait_for_event_client "qsub" 1

   # Qmaster down before qsub -sync y
   set qmaster_pid [get_qmaster_pid $ts_config(master_host) $spool_dir]
   start_remote_prog "$ts_config(master_host)" "root" "kill" "-9 $qmaster_pid"
   set text [translate_macro MSG_GDI_UNABLE_TO_CONNECT_SUS "qmaster" "*" "*"]
   set text2 [translate_macro MSG_GDI_CANT_SEND_MSG_TO_PORT_ON_HOST_SUSS "qmaster" "*" "*" "*"]
   set output [start_remote_prog $host $CHECK_USER "$ts_config(product_root)/bin/$arch/qsub" "-sync y $ts_config(product_root)/examples/jobs/sleeper.sh 10"]

   if {[string match "*$text*" $output] == 0 && [string match "*$text2*" $output] == 0} {
      append error_text "\"Qmaster down before qsub -sync y\" FAILED due to an unexpected output\n"
      set error 1
   }
   startup_qmaster 0
   wait_for_event_client "sched*"

   # Qmaster down after qsub -sync y
   ts_log_fine "Qmaster down after qsub -sync y test"

   del_event_client_list "all" ""
   wait_for_event_client "qsub" 1

   wait_for_end_of_all_jobs 660  ;# qsub -sync jobs have delayed job reporting

   set id [open_remote_spawn_process $host $CHECK_USER "$ts_config(product_root)/bin/$arch/qsub" "-sync y $ts_config(product_root)/examples/jobs/sleeper.sh 120"]
   set sp_id [lindex $id 1]

   expect {
      -i $sp_id timeout {
         append error_text "Timeout in \"Qmaster down after qsub -sync y\" test\n"
         set error 1
      }
      -i $sp_id eof {
         append error_text "Unexpected EOF in \"Qmaster down after qsub -sync y\" test\n"
         set error 1
      }
      # The qmaster has become unreachable
      -i $sp_id -- $SUBMIT_MESSAGE {
         ts_log_fine "Qsub output: job submitted"
      }
      "_END_OF_FILE_" {
         set error 1
         append error_text "Could not submit job to qmaster\n"
         append error_text "$expect_out(buffer)\n"
      }
   }
   wait_for_event_client "qsub"

   set output 0
   set recon 0
   set text [translate_macro MSG_JAPI_DISCONNECTED]
   set text2 [translate_macro MSG_JAPI_RECONNECTED]

   set qmaster_pid [get_qmaster_pid $ts_config(master_host) $spool_dir]
   start_remote_prog "$ts_config(master_host)" "root" "kill" "-9 $qmaster_pid"

   if {[startup_qmaster 0] != 0} {
      ts_log_severe "qmaster could not be started"
   }
   expect {
      -i $sp_id timeout {
         append error_text "Timeout in \"Qmaster down after qsub -sync y\" test\n"
         set error 1
      }
      -i $sp_id eof {
         append error_text "Unexpected EOF in \"Qmaster down after qsub -sync y\" test\n"
         set error 1
      }
      # The qmaster has become unreachable
      -i $sp_id -- $text {
         ts_log_fine "Qsub output: The qmaster has become unreachable."
         set output 1
         exp_continue
      }
      # Reconnected to qmaster
      -i $sp_id -- $text2 {
         ts_log_fine "Qsub output: Reconnected to qmaster."
         set recon 1
      }
      "_END_OF_FILE_" {
         set error 1
         append error_text "Could no reconnect to qmaster\n"
         append error_text "$expect_out(buffer)\n"
      }
   }

   close_spawn_process $id

   delete_all_jobs
   wait_for_end_of_all_jobs 660   ;# qsub -sync jobs have delayed report time
   wait_for_event_client "qsub" 1


   if {$output != 1} {
      append error_text "\"Qmaster down after qsub -sync y\" FAILED due to an unexpected output\n"
      set error 1
   }
   if {$recon != 1} {
      append error_text "\"Qmaster down after qsub -sync y\" FAILED because the event client was unable to reconnect\n"
      set error 1
   }

   if {$error == 1} {
      ts_log_severe $error_text
   }
}

#****** qsub/check_option_pty() ************************************************
#  NAME
#     check_option_pty - Testcase for qsub -pty yes
#
#  SYNOPSIS
#     1. Submit tty-binary as job with -pty yes
#     2. Check if tty-binary exited with 0
#     3. Scan the output file for /dev/pts/
#
#*******************************************************************************
proc check_option_pty {} {
   global ts_config
   global CHECK_USER

   set output_tmpfile [get_tmp_file_name]
   set job_id [submit_job "-pty yes -N tty -o $output_tmpfile -e /dev/null -b y tty"]

   if {$job_id < 1} {
      return
   }

   wait_for_end_of_all_jobs

   if {[get_qacct $job_id] == 0} {
      if {$qacct_info(exit_status) != 0} {
         ts_log_severe "There was not PTY available!"
      }
   }

   set host $ts_config(master_host)
   set result [start_remote_prog $host $CHECK_USER cat $output_tmpfile exit_code]

   if {$exit_code != 0 || $result == ""} {
      ts_log_severe "error reading from output file on host $host:\n$result"
   } else {
      if {[string first "/dev/pts/" $result] != -1} {
         ts_log_info "Found PTY in job-output"
      } else {
         ts_log_severe "No PTY was found in job-output"
      }
   }

   #clean up
   file delete $output_tmpfile
}

#****** qsub/check_option_pty_no () ********************************************
#  NAME
#     check_option_pty_no - Testcase for qsub -pty no
#
#  SYNOPSIS
#     1. Submit tty-binary as job with no pty
#     2. Check if tty-binary exited with 1
#     3. Scan the output file for /dev/pts/. Fail if available!
#
#*******************************************************************************
proc check_option_pty_no {} {
   global ts_config
   global CHECK_USER

   set output_tmpfile [get_tmp_file_name]
   set job_id [submit_job "-N tty -o $output_tmpfile -e /dev/null -b y tty"]

   if {$job_id < 1} {
      return
   }

   wait_for_jobend $job_id "tty" 60

   if {[get_qacct $job_id] == 0} {
      if {$qacct_info(exit_status) != 1} {
         ts_log_severe "There was a PTY available despite -pty no!"
      }
   }

   set host $ts_config(master_host)
   set result [start_remote_prog $host $CHECK_USER cat $output_tmpfile exit_code]

   if {$exit_code != 0 || $result == ""} {
      ts_log_severe "error reading from output file on host $host:\n$result"
   } else {
      if {[string first "/dev/pts/" $result] != -1} {
         ts_log_severe "PTY was found in job-output despite -pty no!"
      } else {
         ts_log_info "Found no PTY in job-output"
      }
   }

   #clean up
   file delete $output_tmpfile
}

#****** qsub/check_option_pty_io () ********************************************
#  NAME
#     check_option_pty_io - Testcase for qsub -pty yes and its IO-redirection
#
#  SYNOPSIS
#     1. Generate a temporary input file with only "TESTINPUT" as content. 
#     2. Submit job with pty -yes and the generated input-file.
#     3. Scan the output file for the content of the input file and the
#        additional ouput of the test-script.
#     4. Check if output file has the right owner
#
#*******************************************************************************
proc check_option_pty_io {} {
   global ts_config
   global CHECK_USER
   global CHECK_FIRST_FOREIGN_SYSTEM_USER
   global CHECK_SECOND_FOREIGN_SYSTEM_USER

   set users [list $CHECK_USER $CHECK_FIRST_FOREIGN_SYSTEM_USER $CHECK_SECOND_FOREIGN_SYSTEM_USER]

   foreach user $users {
      set host $ts_config(master_host)
      set home_dir [get_home_dir_path $user $host]
      set time [timestamp]
      set output_tmpfile "$home_dir/check_option_pty_o$time.tmp"
      set input_tmpfile "$home_dir/check_option_pty_i$time.tmp"
      set uid [get_uid $user $host]

      ts_log_info "Starting check_option_pty_io as user $user"
      start_remote_prog $host $user echo "TESTINPUT >> $input_tmpfile" exit_code

      if {$exit_code != 0} {
         ts_log_severe "Could not write input file"
         return
      }

      wait_for_file $input_tmpfile 10
      set job_id [submit_job "-N pty_io -o $output_tmpfile -e /dev/null -i $input_tmpfile $ts_config(testsuite_root_dir)/scripts/stdin.sh" 1 60 $host $user]

      if {$job_id < 1} {
         start_remote_prog $host $user rm $input_tmpfile
         return
      }

      wait_for_jobend $job_id "pty_io" 60 0
      wait_for_file $output_tmpfile 10

      set result [start_remote_prog $host $user cat $output_tmpfile exit_code]

      if {$exit_code != 0 || $result == ""} {
         ts_log_severe "error reading from output file on host $host:\n$result"
      } else {
         if {[string first "Output to stdout: TESTINPUT" $result] != -1} {
            ts_log_info "Found expected output"
         } else {
            ts_log_severe "Input-file was not parsed correctly! Result was: $result"
         }
      }

      #check output-file if it has the right owner
      if {[file exists $output_tmpfile] == 1} {
         file stat $output_tmpfile file_stat
         if {$uid != $file_stat(uid)} {
            ts_log_severe "$output_tmpfile has the wrong owner! It is $uid but should be $file_stat(uid)"
         }
      } else {
         ts_log_severe "Output-file is missing"
      }

      #clean up
      start_remote_prog $host $user rm $output_tmpfile
      start_remote_prog $host $user rm $input_tmpfile
   }
}
